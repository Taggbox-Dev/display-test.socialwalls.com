{"version":3,"file":"static/js/3594.62fab748.chunk.js","mappings":"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","sources":["app/Components/PhotoBooth/Cards/Cards.js","app/Components/PhotoBooth/Elements/Button.js","app/Components/PhotoBooth/utils/constant.js","app/Components/PhotoBooth/utils/index.js","app/Components/PhotoBooth/Elements/ImagePreview.js","app/Components/PhotoBooth/Elements/Stickers.js","app/Components/PhotoBooth/Elements/Text.js","app/Components/PhotoBooth/Elements/TabComponent.js","app/Components/PhotoBooth/Customization/index.js","app/Components/PhotoBooth/TopBar/TopBar.js","app/Components/PhotoBooth/Elements/CropImage.js","app/Components/PhotoBooth/UserPhoto/UserPhoto.js","app/Components/PhotoBooth/index.js"],"sourcesContent":["import { PhotoBoothMediaUrl } from \"../../../../constants\";\n\nexport default function Cards({ uploadFile }) {\n    return (\n        <div className=\"pb_cards\">\n            <div className=\"pb_cards_box\">\n                <div onClick={() => uploadFile(3)} className=\"pb_card\">\n                    <div className=\"pb_card_icon\">\n                        <img src={`${PhotoBoothMediaUrl}images/photobooth/camera.svg`} alt=\"camera\" />\n                    </div>\n                    <h3 className=\"pb_card-title\">Photobooth</h3>\n                    <p className=\"pb_card-description\"> Add fun stickers and backgrounds before sharing your masterpiece.</p>\n                </div>\n                <div onClick={() => uploadFile(2)}  className=\"pb_card\">\n                    <div className=\"pb_card_icon\">\n                        <img src={`${PhotoBoothMediaUrl}images/photobooth/snapup.svg`} alt=\"snapup\" />\n                    </div>\n                    <h3 className=\"pb_card-title\">Snap & Share</h3>\n                    <p className=\"pb_card-description\">Upload your photos in one go without logging into your social media accounts.</p>\n                </div>\n            </div>\n        </div>\n    )\n}","import { PhotoBoothMediaUrl } from \"../../../../constants\";\n\nconst Button = ({ className, children, icon, onClick }) => {\n    return <button className={className} onClick={onClick}>\n        {icon && <img src={`${PhotoBoothMediaUrl}images/photobooth/${icon}.svg`} alt={icon} />}\n        {children}\n    </button>\n}\n\nexport default Button;","export const CANVAS_WIDTH = 320;\nexport const CANVAS_HEIGHT = 320;\nexport const SETTINGS_TABS = [\n    { id: 'background', label: 'Background' },\n    { id: 'frame', label: 'Frames' },\n    { id: 'sticker', label: 'Stickers' },\n    { id: 'text', label: 'Text' }\n]\nexport const STICKER_HANDLE_SIZE = 15;\nexport const ROTATION_HANDLE_RADIUS = 9;\nexport const ROTATION_HANDLE_OFFSET = 20;\nexport const PHOTOBOT_VERSION = 2.2;","import { detectMobile } from \"../../../../utils\";\nimport { CANVAS_HEIGHT, CANVAS_WIDTH, STICKER_HANDLE_SIZE } from \"./constant\";\n\nconst base64ToFile = (dataUrl, filename) =>  {\n    try {\n    const [header, base64] = dataUrl.split(',');\n    const mime = header.match(/:(.*?);/)[1];\n    const binary = atob(base64);\n    const len = binary.length;\n    const u8arr = new Uint8Array(len);\n\n    for (let i = 0; i < len; i++) {\n        u8arr[i] = binary.charCodeAt(i);\n    }\n\n    return new File([u8arr], filename, { type: mime });\n    } catch (error) {\n        console.error('Error converting base64 data to file:', error);\n        return null;\n    }\n}\n\nconst blobToFile = (blob, fileName) => {\n  return new File([blob], fileName, { name: \"camera.png\", type: blob.type, lastModified: Date.now() });\n};\n\nexport const handleImageChangeBlob = (mediaContent, type, uploadAction) => {\n    let file = type == \"blob\" ? blobToFile(mediaContent) : mediaContent;\n    if (file) {\n        const imageUrl = URL.createObjectURL(file);\n        if(imageUrl && uploadAction) uploadAction(imageUrl);\n    }\n}\n\nexport const handleImageChange = (mediaContent, type, uploadAction) => {\n    console.log(mediaContent,'mediaContentmediaContentds')\n    let file = type == \"blob\" ? base64ToFile(mediaContent, \"camera.png\") : mediaContent;\n    if (file) {\n        const imageUrl = URL.createObjectURL(file);\n        if(imageUrl && uploadAction) uploadAction(imageUrl);\n    }\n}\n\n// // Helper function to check if mouse is over a sticker's resize handle\nexport const isOverResizeHandle = (sticker, mouseX, mouseY) => {\n    const stickerWidth = sticker.img.width * sticker.scale;\n    const stickerHeight = sticker.img.height * sticker.scale;\n\n    // Rotation in radians\n    const angleRad = (sticker.rotation || 0) * Math.PI / 180;\n\n    // Sticker center\n    const centerX = sticker.x + stickerWidth / 2;\n    const centerY = sticker.y + stickerHeight / 2;\n\n    // Handle position before rotation (bottom-right corner)\n    const localHandleX = stickerWidth / 2;\n    const localHandleY = stickerHeight / 2;\n\n    // Apply rotation to handle position\n    const rotatedHandleX = centerX + (localHandleX * Math.cos(angleRad) - localHandleY * Math.sin(angleRad));\n    const rotatedHandleY = centerY + (localHandleX * Math.sin(angleRad) + localHandleY * Math.cos(angleRad));\n\n    // Distance from mouse to handle center\n    const dx = mouseX - rotatedHandleX;\n    const dy = mouseY - rotatedHandleY;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // Handle radius\n    const handleRadius = getTouchDeviceFraction(STICKER_HANDLE_SIZE, 7) / 2;\n    return distance <= (handleRadius * 4);\n};\n\n// Helper function to check if mouse is over a sticker's main body\nexport const isOverSticker = (sticker, mouseX, mouseY) => {\n    const stickerWidth = sticker.img.width * sticker.scale;\n    const stickerHeight = sticker.img.height * sticker.scale;\n    return (\n        mouseX > sticker.x &&\n        mouseX < sticker.x + stickerWidth &&\n        mouseY > sticker.y &&\n        mouseY < sticker.y + stickerHeight\n    );\n};\n\nexport const isOverRotationHandle = (sticker, mouseX, mouseY) => {\n    const { img, scale, x, y, rotation = 0 } = sticker;\n\n    const width = img.width * scale;\n    const height = img.height * scale;\n\n    // Sticker center\n    const centerX = x + width / 2;\n    const centerY = y + height / 2;\n\n    // Offset to top-right corner, then move up by ROTATION_HANDLE_OFFSET\n    const handleLocalX = width / 2;\n    const handleLocalY = -height / 2 - 3;\n\n    // Convert rotation degrees to radians\n    const rad = (rotation * Math.PI) / 180;\n\n    // Rotate handle position around center\n    const handleRotatedX = centerX + (handleLocalX * Math.cos(rad)) - (handleLocalY * Math.sin(rad));\n    const handleRotatedY = centerY + (handleLocalX * Math.sin(rad)) + (handleLocalY * Math.cos(rad));\n\n    const dx = mouseX - handleRotatedX;\n    const dy = mouseY - handleRotatedY;\n\n\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    const handleRadius = getTouchDeviceFraction(STICKER_HANDLE_SIZE, 7);\n    return distance <= (handleRadius*4);\n\n\n    //return Math.sqrt(dx * dx + dy * dy) <= getTouchDeviceFraction(ROTATION_HANDLE_RADIUS, 7);\n};\n\nexport const isOverText = (textObj, mouseX, mouseY, textWidth, capturedImage) => {\n    const { initialWidthRatio, initialHeightRatio } = getInitialRatio(capturedImage);\n\n    const scale = textObj.scale || 1;\n    const fontSize = textObj.fontSize || 20;\n\n    // ✅ Normalize center into canvas space\n    const centerX = textObj.x;\n    const centerY = textObj.y;\n\n    // ✅ Normalize dimensions\n    const width = (textWidth * scale + 20) * initialWidthRatio;\n    const lines = (textObj.text?.split(\"\\n\") || []).length;\n    const height = (lines * fontSize * scale + 20) * initialHeightRatio;\n\n    const extraHeight = detectMobile() ? (scale > 0 ? 20 / scale : 20) : 0;\n\n    // Translate mouse relative to center\n    const dx = mouseX - centerX;\n    const dy = mouseY - centerY;\n\n    const angleRad = (textObj.rotation || 0) * Math.PI / 180;\n    const cos = Math.cos(-angleRad);\n    const sin = Math.sin(-angleRad);\n\n    // Undo rotation and scale (all in canvas space now)\n    const localX = (dx * cos - dy * sin) / scale;\n    const localY = (dx * sin + dy * cos) / scale;\n\n    // Bounding box check\n    return (\n        localX >= -width / (2 * scale) &&\n        localX <= width / (2 * scale) &&\n        localY >= -height / (2 * scale) - extraHeight &&\n        localY <= height / (2 * scale) + extraHeight\n    );\n};\n\nexport const isOverTextResizeHandle = (textObj, mouseX, mouseY, textWidth, capturedImage) => {\n    const { initialWidthRatio, initialHeightRatio } = getInitialRatio(capturedImage);\n    const scaleRatio = Math.max(initialWidthRatio, initialHeightRatio);\n    const scale = textObj.scale || 1;\n    const fontSize = textObj.fontSize || 20;\n    const lines = (textObj.text?.split('\\n') || []);\n    const lineCount = Math.max(lines.length, 1);\n    const lineHeight = fontSize * 1.2;\n    const totalTextHeight = lineHeight * lineCount;\n    const height = totalTextHeight * scale + 20;\n\n    const width = textWidth * scale + 20; // width already measured and passed\n\n    const handleSize = getTouchDeviceFraction(16);\n\n    // Center of the text\n    const centerX = textObj.x;\n    const centerY = textObj.y;\n\n    // Rotation handle: top-right before rotation\n    const offsetX = (width / 2) * initialWidthRatio;\n    const offsetY = (height / 2) * initialHeightRatio;\n\n    const angleRad = (textObj.rotation || 0) * Math.PI / 180;\n\n    // Rotate the offset vector\n    const handleX = centerX + (offsetX * Math.cos(angleRad)) - (offsetY * Math.sin(angleRad));\n    const handleY = centerY + (offsetX * Math.sin(angleRad)) + (offsetY * Math.cos(angleRad));\n\n    const dx = mouseX - handleX;\n    const dy = mouseY - handleY;\n\n    return dx * dx + dy * dy < (handleSize / 2) ** 2 * (scaleRatio ** 2);\n};\n\nexport const isOverTextRotationHandle = (textObj, mouseX, mouseY, textSectionWidth, capturedImage) => {\n    const { initialWidthRatio, initialHeightRatio } = getInitialRatio(capturedImage);\n    const scaleRatio = Math.max(initialWidthRatio, initialHeightRatio);\n    const scale = textObj.scale || 1;\n    const fontSize = textObj.fontSize || 20;\n    const handleSize = getTouchDeviceFraction(16);\n\n    const centerX = textObj.x;\n    const centerY = textObj.y;\n\n    // Estimated multiline height (at least 1 line)\n    const lines = (textObj.text?.split('\\n') || []);\n    const lineCount = Math.max(lines.length, 1);\n    const lineHeight = fontSize * 1.2;\n    const totalTextHeight = lineHeight * lineCount;\n    const height = totalTextHeight * scale + 20;\n    const width = textSectionWidth * scale + 20;\n\n    // Rotation handle: top-right before rotation\n    const offsetX = (width / 2) * initialWidthRatio;\n    const offsetY = (-height / 2) * initialHeightRatio;\n\n    const angleRad = (textObj.rotation || 0) * Math.PI / 180;\n\n    // Final handle position\n    const handleX = centerX + offsetX * Math.cos(angleRad) - offsetY * Math.sin(angleRad);\n    const handleY = centerY + offsetX * Math.sin(angleRad) + offsetY * Math.cos(angleRad);\n\n    const dx = mouseX - handleX;\n    const dy = mouseY - handleY;\n    return (dx * dx + dy * dy) < ((handleSize / 2) ** 2) * (scaleRatio ** 2);\n}\n\nexport const wrapText = (width, text, maxWidth) => {\n    const words = text.split(' ');\n    const lines = [];\n    let line = '';\n\n    for (let i = 0; i < words.length; i++) {\n        const testLine = line + words[i] + ' ';\n        const testWidth = width * maxWidth;\n        if (testWidth > maxWidth && i > 0) {\n            lines.push(line.trim());\n            line = words[i] + ' ';\n        } else line = testLine;\n    }\n    lines.push(line.trim());\n    return lines;\n}\n\nexport const getTouchDeviceFraction = (num, fraction = 0) => detectMobile() ? (num * 2) + fraction : num;\n\nexport const rotatePoint = (x, y, cx, cy, angle) => {\n    const rad = (angle * Math.PI) / 180;\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n\n    return {\n        x: cx + (x - cx) * cos - (y - cy) * sin,\n        y: cy + (x - cx) * sin + (y - cy) * cos,\n    };\n}\n\nexport const getInitialRatio = (image) => {\n    const initialWidthRatio = Math.max(1, image ? image.width / CANVAS_WIDTH : 1);\n    const initialHeightRatio = Math.max(1, image ? image.height / CANVAS_HEIGHT : 1);\n    return { initialWidthRatio, initialHeightRatio }\n}","import React, { useCallback, useEffect, useMemo, useState } from \"react\";\nimport Webcam from \"react-webcam\";\nimport { PhotoBoothMediaUrl } from \"../../../../constants\";\nimport { CANVAS_WIDTH, CANVAS_HEIGHT } from \"../utils/constant\";\nimport { detectMobile } from \"../../../../utils\";\nimport { getInitialRatio } from \"../utils\";\n\nconst ImagePreview = ({ rawImage, cameraPermission, capturedImage, mode, counter, canvasRef, canvasCursor, webcamRef, onMouseDown, onMouseMove, onMouseUp, canvasElements, activeTextIndex, setCanvasElements, loading }) => {\n    const [facingMode, setFacingMode] = useState(\"environment\");\n    const [camKey, setCamKey] = useState(Math.random()); // key to force re-mount\n\n    const getLineCount = (text) => {\n        if (!text) return 1;\n        return text.split('\\n').length;\n    };\n\n    const isMobile = useMemo(detectMobile, []);\n\n    const { initialWidthRatio, initialHeightRatio } = useMemo(() => {\n        return getInitialRatio(capturedImage);\n    }, [capturedImage]);\n\n    const wrapText = (inputText) => {\n        if (!canvasRef.current || !canvasElements[activeTextIndex]) return inputText;\n\n        const element = canvasElements[activeTextIndex];\n        const canvas = document.createElement(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n\n        const fontSize = element.fontSize || 16;\n        const fontFamily = element.fontFamily || \"Arial\";\n        ctx.font = `${fontSize}px ${fontFamily}`;\n\n        const maxWidth = 270;\n        const words = inputText.split(/\\s+/);\n        let line = \"\";\n        let result = \"\";\n\n        const splitLongWord = (word) => {\n            let temp = \"\";\n            for (let char of word) {\n                const testLine = temp + char;\n                if (ctx.measureText(testLine).width > maxWidth && temp) {\n                    result += temp + \"\\n\";\n                    temp = char;\n                } else {\n                    temp = testLine;\n                }\n            }\n            return temp;\n        };\n\n        for (let word of words) {\n            let testLine = line ? line + \" \" + word : word;\n            if (ctx.measureText(testLine).width > maxWidth) {\n                if (!line) {\n                    // word itself is too long, break it up\n                    line = splitLongWord(word);\n                } else {\n                    result += line + \"\\n\";\n                    if (ctx.measureText(word).width > maxWidth) {\n                        line = splitLongWord(word);\n                    } else {\n                        line = word;\n                    }\n                }\n            } else {\n                line = testLine;\n            }\n        }\n\n        if (line) result += line;\n\n        return result;\n    };\n\n    const handleChange = (e) => {\n        const rawText = e.target.value;\n        if (rawText?.length <= 35) {\n            const wrappedText = wrapText(rawText);\n            console.log(\"wrappedText\", wrappedText)\n            setCanvasElements((prev) => prev.map((el, i) => i === activeTextIndex ? { ...el, text: wrappedText } : el));\n        }\n    };\n\n    const measureTextWidth = useCallback((element) => {\n        if (!element || !element.text) return 0;\n\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        const fontSize = element.fontSize || 16;\n        const fontFamily = element.fontFamily || 'Arial';\n        const scale = element.scale || 1;\n\n        ctx.font = `${fontSize}px ${fontFamily}`;\n\n        const lines = element.text.split('\\n');\n\n\n        // Measure all lines and get the max width\n        const maxWidth = Math.max(...lines.map(line => ctx.measureText(line).width));\n\n        return maxWidth * scale;\n    }, []);\n\n    function handleTouchStart(e) {\n        const isTouch = e.type.startsWith(\"touch\");\n        e.preventDefault(); // Stop scrolling while dragging\n        const touch = e.touches[0];\n        const simulatedEvent = {\n            clientX: touch.clientX,\n            clientY: touch.clientY,\n        };\n        onMouseDown(simulatedEvent, isTouch);\n    }\n\n    function handleTouchMove(e) {\n        e.preventDefault();\n        const touch = e.touches[0];\n        const simulatedEvent = {\n            clientX: touch.clientX,\n            clientY: touch.clientY,\n        };\n        onMouseMove(simulatedEvent);\n    }\n\n    function handleTouchEnd(e) {\n        e.preventDefault();\n        onMouseUp(); // No coordinates needed \n    }\n\n    const startCamera = async () => {\n        try {\n            setTimeout(() => {\n                setCamKey(Date.now()); // force new mount\n            }, 2000);\n        } catch (err) {\n            console.error(\"Error starting camera:\", err);\n        }\n    };\n\n    // Mount hone par camera start karo\n    useEffect(() => {\n        startCamera();\n        return () => stopCamera(); // unmount hone par stop\n    }, []);\n\n    const stopCamera = () => {\n        setTimeout(() => {\n            if (webcamRef?.current) {\n                webcamRef?.current?.stream && webcamRef.current.stream.getTracks().forEach(track => track.stop());\n            }\n        }, 1000);\n    };\n\n\n    // Function to toggle camera\n    // Toggle camera between front and back\n    const toggleCamera = useCallback(() => {\n        setFacingMode((prev) => (prev === \"user\" ? \"environment\" : \"user\"));\n        setCamKey(prev => prev + 1);\n    }, []);\n\n\n\n    return (\n        <>\n            <div className={`pb_user_photo ${loading ? 'active_blur' : ''}`} style={{ position: \"relative\", display: rawImage && !isMobile ? 'none' : capturedImage || cameraPermission === \"granted\" ? 'flex' : 'none' }}>\n                {(mode === \"capture\" && !capturedImage) ? (\n                    <Webcam\n                        key={`${camKey}-${facingMode}`} // full reload each switch\n                        ref={webcamRef}\n                        screenshotFormat=\"image/png\"\n                        width={CANVAS_WIDTH}\n                        height={CANVAS_HEIGHT}\n                        videoConstraints={{\n                            facingMode, // \"user\" or \"environment\"\n                            width: { min: 640, ideal: 1920, max: 3840 },  // allow up to 4K if supported\n                            height: { min: 480, ideal: 1080, max: 2160 }  // scale accordingly\n                        }}\n                        mirrored={facingMode === \"user\"} // mirror only for front camera\n                        onUserMedia={() => console.log(\"Webcam stream started:\", facingMode)}\n                        style={{ objectFit: \"cover\", borderRadius: \"8px\" }}\n                    />\n                ) : capturedImage ? <canvas ref={canvasRef} style={{ cursor: canvasCursor, width: `${CANVAS_WIDTH}px`, height: `${CANVAS_HEIGHT}px` }}\n                    onMouseDown={onMouseDown}\n                    onMouseMove={onMouseMove}\n                    onMouseUp={onMouseUp}\n                    onMouseLeave={onMouseUp}\n                    onTouchStart={handleTouchStart}\n                    onTouchMove={handleTouchMove}\n                    onTouchEnd={handleTouchEnd} />\n                    : <img src={`${PhotoBoothMediaUrl}images/photobooth/avatar.png?v=1.0.1`} alt=\"default-avatar\" width={CANVAS_WIDTH} height={CANVAS_HEIGHT} />}\n                {canvasElements?.map((element, index) => (\n                    activeTextIndex === index && (\n                        <textarea\n                            id={`text-${index}`}\n                            name={`text-${index}`}\n                            key={index}\n                            value={element.text}\n                            onChange={handleChange}\n                            wrap=\"hard\"\n                            style={{\n                                position: \"absolute\",\n                                top: `${(element.y / initialHeightRatio) - ((element.fontSize * element.scale * getLineCount(element.text) + (element.scale * initialHeightRatio)) / 2)}px`,\n                                left: `${(element.x / initialWidthRatio) - (measureTextWidth(element) / 2) - ((isMobile ? 3 : 0))}px`, // scale is already applied inside measureTextWidth\n                                width: `${measureTextWidth(element)}px`,\n                                height: `${(element.fontSize * element.scale) * getLineCount(element.text) + 5}px`,\n                                fontSize: `${element.fontSize * element.scale}px`,\n                                fontFamily: element.fontFamily || 'Arial',\n                                transform: `rotate(${element.rotation || 0}deg)`,\n                                textAlign: element.align || 'center',\n                                transformOrigin: 'center center',\n                                background: element.backgroundColor || 'transparent',\n                                color: element.color || '#000',\n                                overflow: 'hidden',\n                                border: 'none',\n                                outline: 'none',\n                                padding: 0,\n                                maxWidth: '300px',\n                                wordBreak: 'break-word',\n                                whiteSpace: 'pre-wrap',\n                                overflowWrap: 'break-word',\n                                resize: 'none'\n                            }}\n                        />\n                    )\n                ))}\n                {(isMobile && !capturedImage) ? <button onClick={toggleCamera}>\n                    <img src={`${PhotoBoothMediaUrl}images/photobooth/camera-flip.svg`} alt=\"flip-camera\" />\n                </button> : null}\n                {counter ? <div className=\"pb_viewframe\"><img src={`${PhotoBoothMediaUrl}images/photobooth/viewframe-white@3x.svg`} alt=\"viewframe\" /> <span>{counter}</span></div> : null}\n            </div></>\n    )\n}\n\nexport default React.memo(ImagePreview);","import { PHOTOBOT_VERSION } from \"../utils/constant\";\n\nconst Stickers = ({ addSticker, loading, stickers, selectedStickers }) => {\n    return (\n        <div className=\"pb_tabs_content_box\">\n            <div className=\"pb_list_items pb_stickers\">\n                {stickers.map((sticker, index) => {\n                    const active = selectedStickers?.find(item => item?.url == sticker);\n                    return <img key={index} onClick={loading ? null : () => addSticker(sticker)} style={{ cursor: loading ? 'not-allowed' : 'pointer' }} className={active ? 'active' : ''} src={`${sticker}?v=${PHOTOBOT_VERSION}`} alt=\"sticker\" width={64} height={64} />\n                })}\n            </div>\n        </div>\n    )\n}\n\nexport default Stickers;","import { ChromePicker } from \"react-color\";\nimport { CloudUrl } from \"../../../../constants\";\nimport React, { useEffect, useRef, useState } from \"react\";\n\nconst texts = ['font', 'align', 'color', 'bg'];\nconst fontFamilies = ['Georgia', 'Arial', 'Helvetica', 'Times New Roman', 'Courier New', 'Verdana', 'Tahoma', 'Trebuchet MS', 'Comic Sans MS', 'Impact', 'Lucida Console', 'Roboto', 'Open Sans'];\nconst aligns = ['left', 'center', 'right'];\nconst bgColors = ['white', 'black', 'transparent'];\n\nconst Text = ({ canvasElements, setCanvasElements, activeTextIndex, addTextElement }) => {\n    const [colorPicker, setcolorPicker] = useState(0);\n    const pickerRef = useRef(null);\n\n    const addChangesToElement = (mode) => {\n        if (activeTextIndex !== null) {\n            const change = {};\n            if (mode === 'color') {\n                setcolorPicker(1)\n                return\n            }\n\n            if (mode === 'align') {\n                const activeText = canvasElements[activeTextIndex]?.align ?? \"center\";\n                const align = aligns.find((align) => align === activeText);\n                change.align = aligns[(aligns.indexOf(align) + 1) % aligns.length];\n            } else if (mode === 'bg') {\n                const activeBgColor = canvasElements[activeTextIndex]?.backgroundColor ?? \"transparent\";\n                const bgColor = bgColors.find((bgColor) => bgColor === activeBgColor);\n                change.backgroundColor = bgColors[(bgColors.indexOf(bgColor) + 1) % bgColors.length];\n            } else if (mode === 'font') {\n                const activeFont = canvasElements[activeTextIndex]?.fontFamily ?? \"Arial\";\n                const i = Math.max(0, fontFamilies.indexOf(activeFont));\n                change.fontFamily = fontFamilies[(i + 1) % fontFamilies.length];\n            }\n            setCanvasElements((prev) => prev.map((el, i) => i === activeTextIndex ? { ...el, ...change } : el))\n        }\n    }\n\n    useEffect(() => {\n        const handleClickOutside = (event) => {\n            if (pickerRef.current && !pickerRef.current.contains(event.target)) {\n                setcolorPicker(false);\n            }\n        };\n        document.addEventListener(\"mousedown\", handleClickOutside);\n        document.addEventListener(\"touchstart\", handleClickOutside);\n        return () => {\n            document.removeEventListener(\"mousedown\", handleClickOutside);\n            document.removeEventListener(\"touchstart\", handleClickOutside);\n        };\n    }, []);\n\n    return (\n        <>\n            {colorPicker ? <div ref={pickerRef}><ChromePicker\n                color={canvasElements[activeTextIndex]?.color ?? \"black\"}\n                onChange={(updatedColor) => setCanvasElements((prev) => prev.map((el, i) => i === activeTextIndex ? { ...el, color: updatedColor.hex } : el))}\n            /></div> : null}\n            <div className=\"pb_tabs_content_box\">\n                <div className=\"pb_text\">\n                    {texts.map((text) => (\n                        <div className=\"pb_text_box\" key={text}  onClick={() => addChangesToElement(text)} >\n                            <img src={`${CloudUrl}/media/images/photobooth/text/${text}.png?v=1`} alt={text} />\n                            <p>{text}</p>\n                        </div>\n                    ))}\n                </div>\n                <div className=\"pb_add_text\">\n                    <p onClick={addTextElement}>Add Text</p>\n                </div>\n            </div>\n            </>\n    )\n}\n\nexport default (Text);","import { CloudUrl } from \"../../../../constants\";\nimport { PHOTOBOT_VERSION } from \"../utils/constant\";\n\nconst TabComponent = ({ loading, imgUrl, imgList, setImgUrl, tabKey, capturedImage = null }) => {\n    return (\n        <div className=\"pb_tabs_content_box\">\n        <div className={`pb_list_items pb_${tabKey}`}>\n            {[`${CloudUrl}/media/images/photobooth/${tabKey}/none.png`,...imgList].map((img, index) => {\n                const active = imgUrl ? imgUrl === img : index === 0;\n                return <div className={`pb_list_images ${active ? 'active' : ''}`} key={index}>\n                    {capturedImage && index !== 0 ? <img className=\"pb_list_user_img\" src={capturedImage?.src} alt=\"captured-image\" width={64} height={64} /> : null}\n                    <img style={{ cursor: loading ? 'not-allowed' : 'pointer' }} src={`${img}?v=${PHOTOBOT_VERSION}`} alt={`img-${index}`} className={'pb_list_frames'} width={64} height={64} onClick={loading ? null : () => setImgUrl(index == 0 ? null : img)} /> \n                </div>\n            })}\n        </div>\n        </div>\n    )\n}\n\nexport default TabComponent;","import { useEffect, useState } from 'react';\nimport Button from \"../Elements/Button\";\nimport ImagePreview from '../Elements/ImagePreview';\nimport Stickers from '../Elements/Stickers';\nimport Text from '../Elements/Text';\nimport TabComponent from '../Elements/TabComponent';\nimport { SETTINGS_TABS } from '../utils/constant';\nimport { parseStringObj } from '../../../../utils';\nimport { PhotoBoothMediaUrl } from '../../../../constants';\n\nconst Customization = ({ capturedImage, uploadFile, canvasRef, canvasCursor, selectedBg, setSelectedBg, selectedFrame, setSelectedFrame, addSticker, addTextElement, onMouseDown, onMouseMove, onMouseUp, canvasElements, setCanvasElements, activeTextIndex, loading, selectedStickers, photoBoothSettings, setActiveStickerIndex, setActiveTextIndex, activeText }) => {\n    const [activeTab, setActiveTab] = useState('background');\n    const [backgrounds, setBackgrounds] = useState([]);\n    const [frames, setFrames] = useState([]);\n    const [stickers, setStickers] = useState([]);\n\n    const continueAction = () => {\n        if(canvasRef?.current) {\n            const canvas = canvasRef.current;\n            setActiveStickerIndex(null);\n            setActiveTextIndex(null);\n            setTimeout(() => {\n                const dataURL = canvas.toDataURL(\"image/png\", 1.0);\n                if(dataURL) uploadFile(2, dataURL);\n            }, 100);\n        }\n    }\n\n    useEffect(() => {\n        if(activeTab === 'text' && canvasElements.length === 0) addTextElement();\n        if(activeTab !== 'text') setActiveTextIndex(null);\n        else if(activeTab !== 'sticker') setActiveStickerIndex(null);\n    }, [activeTab])\n\n    useEffect(() => {\n        const frames = parseStringObj(photoBoothSettings?.photo_booth_frames || []);\n        const backgrounds = parseStringObj(photoBoothSettings?.photo_booth_backgrounds || []);\n        const stickers = parseStringObj(photoBoothSettings?.photo_booth_stickers || []);\n        setFrames(frames?.map(item => `${PhotoBoothMediaUrl}images/photobooth/frames/${item}`));\n        setBackgrounds(backgrounds?.map(item => `${PhotoBoothMediaUrl}images/photobooth/backgrounds/${item}`));\n        setStickers(stickers?.map(item => `${PhotoBoothMediaUrl}images/photobooth/stickers/${item}`));\n    }, [])\n    \n    return (\n        <>\n            <div className=\"pb_customization\">\n                <ImagePreview {...{ loading, capturedImage, canvasRef, canvasCursor, onMouseDown, onMouseMove, onMouseUp, canvasElements, activeTextIndex, setCanvasElements, activeText }} />\n                <div className=\"pb_tabs\">\n                    <div className=\"pb_tabs_list\">\n                        {SETTINGS_TABS.map(tab => (\n                            <button key={tab.id} onClick={() => setActiveTab(tab.id)} className={activeTab === tab.id ? 'active' : ''}>\n                                {tab.label}\n                            </button>\n                        ))}\n                    </div>\n\n                    <div className=\"pb_tabs_content\">\n                        {activeTab === 'background' ? <TabComponent loading={loading} imgUrl={selectedBg} imgList={backgrounds} setImgUrl={setSelectedBg} tabKey=\"backgrounds\" /> : activeTab === 'frame' ? <TabComponent imgUrl={selectedFrame} imgList={frames} setImgUrl={setSelectedFrame} tabKey=\"frames\" capturedImage={capturedImage} /> : activeTab === 'sticker' ? <Stickers {...{ stickers, addSticker, loading, selectedStickers }} /> : activeTab === 'text' ? <Text {...{ canvasElements, setCanvasElements, activeTextIndex, addTextElement }} /> : null}\n                    </div>\n                </div> \n            </div>\n            <div className='pb_continue_buttons_main'>\n                <Button className=\"pb_continue_buttons\" children=\"Continue\" onClick={continueAction}/>\n            </div>\n        </>\n    )\n}\n\nexport default Customization;","import { onsiteRedirectUrl } from \"../../../../actions/api\";\nimport { CloudUrl } from \"../../../../constants\";\n\nexport default function TopBar(props) {\n\nconst {  snapType, uploadType, rawImage, capturedImage, wall, uploadImg, backAction } = props   \n\nconst goBack = \n  (snapType === 1 && uploadType === 1) ||\n  (snapType === 3 && !rawImage && !capturedImage);\n\n    return (\n        <div className=\"pb_header_bar\" onClick={goBack ? ()=> window.location.href = `${onsiteRedirectUrl}${wall.Wall.id}?social-wall=true` : backAction} >\n            <img src={`${CloudUrl}/media/images/photobooth/arrow-back.svg`} alt=\"arrow-back\"/>\n            {/* { uploadType==2 && uploadImg ? <img className=\"pb_header_logo\" src={wall.PhotoBoothSettings.photo_booth_logo} height={20} width={130} alt='' />: null } */}\n            <span className=\"header-title\">{ goBack ? 'Back to Wall' : 'Back' }</span>\n        </div>\n    )\n}   ","import React, { useState, useRef, useEffect, useCallback } from \"react\";\nimport { Rnd } from \"react-rnd\";\nimport { CloudUrl } from \"../../../../constants\";\n\nconst ImageCropEditor = ({ imageUrl, photoBtnRef, customiseImage }) => {\n    const containerRef = useRef(null);\n    const imageRef = useRef(null);\n    const initialDistanceRef = useRef(null);\n    const initialZoomRef = useRef(1);\n    const [showCropIcon, setShowCropIcon] = useState(true);\n    const [imageSize, setImageSize] = useState({ width: 200, height: 200 });\n    const [position, setPosition] = useState({ x: 0, y: 0 });\n    const [zoom, setZoom] = useState(1);\n\n    const containerWidth = 320;\n    const containerHeight = 320;\n\n    // // Function to capture the visible portion of the image\n    const handleCapture = useCallback(() => {\n        const originalImage = imageRef.current;\n        if (!originalImage) {\n            console.error(\"Original image not loaded.\");\n            return null;\n        }\n\n        // Ratios: map container space → original image space\n        const ratioX = originalImage.naturalWidth / imageSize.width;\n        const ratioY = originalImage.naturalHeight / imageSize.height;\n\n        // Map crop box (position/zoom from container → full-res image)\n        const sx = -position.x / zoom * ratioX;\n        const sy = -position.y / zoom * ratioY;\n        const sWidth = containerWidth / zoom * ratioX;\n        const sHeight = containerHeight / zoom * ratioY;\n\n        // Always export at 320×320\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = sWidth;\n        canvas.height = sHeight;\n        const ctx = canvas.getContext(\"2d\");\n\n        // Draw full-resolution crop into fixed 320×320 canvas\n        ctx.drawImage(\n            originalImage,\n            sx, sy, sWidth, sHeight, // source (full-res crop area)\n            0, 0, sWidth, sHeight // destination (fixed size)\n        );\n\n        // Get PNG (lossless)\n        canvas.toBlob((blob) => {\n            if (blob) {\n                const file = new File([blob], \"capture.png\", { type: \"image/png\" });\n                customiseImage(file);\n            }\n        }, \"image/png\");\n    }, [position, zoom, imageSize, containerWidth, containerHeight, customiseImage]); \n\n    useEffect(() => {\n        const img = new Image();\n        img.crossOrigin = \"anonymous\";\n        img.onload = () => {\n            const ratio = img.width / img.height;\n            let width = containerWidth;\n            let height = width / ratio;\n\n            if (height > containerHeight) {\n                height = containerHeight;\n                width = height * ratio;\n            }\n\n            setImageSize({ width, height });\n            setPosition({\n                x: (containerWidth - width) / 2,\n                y: (containerHeight - height) / 2,\n            });\n        };\n        img.src = imageUrl;\n    }, [imageUrl]);\n\n    const scaledWidth = imageSize.width * zoom;\n    const scaledHeight = imageSize.height * zoom;\n\n    const handleWheel = (e) => {\n        e.preventDefault();\n        const zoomDelta = e.deltaY < 0 ? 0.05 : -0.05;\n        const newZoom = Math.max(1, zoom + zoomDelta);\n        const willBeFullWidth = scaledWidth <= containerWidth;\n        const willBeFullHeight = scaledHeight <= containerHeight;\n        if (newZoom <= 1.01 && willBeFullWidth && willBeFullHeight) {\n            setZoom(1); // snap to exact 1x\n            const newX = (containerWidth - imageSize.width) / 2;\n            const newY = (containerHeight - imageSize.height) / 2;\n            setPosition({ x: newX, y: newY });\n        } else {\n            setZoom(newZoom);\n        }\n    };\n\n    const handleDragStop = (e, d) => {\n        // Clamp image position within bounds if image is smaller than container\n        let newX = d.x;\n        let newY = d.y;\n\n        const maxOffsetX = Math.max(0, (scaledWidth - containerWidth));\n        const maxOffsetY = Math.max(0, (scaledHeight - containerHeight));\n\n        newX = Math.min(Math.max(newX, -maxOffsetX), 0);\n        newY = Math.min(Math.max(newY, -maxOffsetY), 0);\n\n        setPosition({ x: newX, y: newY });\n    };\n\n    const getDistance = (touches) => {\n        const [touch1, touch2] = touches;\n        const dx = touch1.clientX - touch2.clientX;\n        const dy = touch1.clientY - touch2.clientY;\n        return Math.sqrt(dx * dx + dy * dy);\n    };\n\n    const handleTouchStart = (e) => {\n        if (e.touches.length === 2) {\n            initialDistanceRef.current = getDistance(e.touches);\n            initialZoomRef.current = zoom;\n        }\n    };\n\n    const handleTouchMove = (e) => {\n        if (e.touches.length === 2) {\n            e.preventDefault();\n            const currentDistance = getDistance(e.touches);\n            const initialDistance = initialDistanceRef.current;\n            const startZoom = initialZoomRef.current;\n\n            if (!initialDistance || !startZoom) return;\n\n            const scaleFactor = currentDistance / initialDistance;\n            let newZoom = Math.max(1, startZoom * scaleFactor);\n            setZoom(newZoom);\n        }\n    };\n\n    useEffect(() => {\n        const container = containerRef.current;\n        if (!container) return;\n\n        container.addEventListener('touchstart', handleTouchStart, { passive: false });\n        container.addEventListener('touchmove', handleTouchMove, { passive: false });\n\n        return () => {\n            container.removeEventListener('touchstart', handleTouchStart);\n            container.removeEventListener('touchmove', handleTouchMove);\n        };\n    }, [zoom])\n\n    useEffect(() => {\n        const timer = setTimeout(() => {\n            setShowCropIcon(false);\n        }, 2500);\n        return () => clearTimeout(timer);\n    }, []);\n\n    return (\n        <div\n            style={{\n                position: \"relative\",\n                overflow: \"hidden\",\n                margin: \"0px auto 30px\",\n                background: \"#f9f9f9\",\n                touchAction: \"none\",\n                border: \"2px dashed #aaa\",\n                borderRadius: '8px'\n            }}\n            onWheel={handleWheel}\n        >\n            <div style={{ width: containerWidth, height: containerHeight }} ref={containerRef}>\n                <Rnd\n                    size={{ width: scaledWidth, height: scaledHeight }}\n                    position={position}\n                    enableResizing={false}\n                    disableDragging={false}\n                    onDragStop={handleDragStop}\n                    style={{\n                        zIndex: 2,\n                        pointerEvents: \"auto\",\n                    }}>\n                    <img\n                        ref={imageRef}\n                        src={imageUrl}\n                        alt=\"Editable\"\n                        style={{\n                            width: \"100%\",\n                            height: \"100%\",\n                            objectFit: \"cover\",\n                            userSelect: \"none\",\n                            pointerEvents: \"none\",\n                        }}\n                    />\n                </Rnd>\n            </div>\n            <button ref={photoBtnRef} style={{ display: \"none\", position: \"absolute\", top: 10, right: 10, zIndex: 400 }} onClick={handleCapture}>Capture</button>\n            {showCropIcon ? <div className=\"pb_take_photo_crop\">\n                <img src={`${CloudUrl}/media/images/photobooth/arrow-left.svg`} alt=\"arrow-left\" width={50} height={50} />\n                <img src={`${CloudUrl}/media/images/photobooth/arrow-right.svg`} alt=\"arrow-right\" width={50} height={50} />\n            </div> : null}\n        </div>\n    );\n};\n\nexport default ImageCropEditor;\n","import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport Button from \"../Elements/Button\";\nimport ImagePreview from \"../Elements/ImagePreview\";\nimport { handleImageChange, handleImageChangeBlob } from \"../utils\";\nimport ImageEditor from \"../Elements/CropImage\";\nimport { PhotoBoothMediaUrl } from \"../../../../constants\";\nimport { isMobile } from \"react-device-detect\";\n\nconst UserPhoto = ({ uploadType, rawImage, takePhoto, canvasRef, canvasCursor, setRawImage, customisePhoto }) => {\n    const uploaderRef = useRef(null);\n    const webcamRef = useRef(null);\n    const photoBtnRef = useRef(null);\n    const [counter, setCounter] = useState(null);\n    const [mode, setMode] = useState(\"capture\");\n    const [uploadedCount, setUploadedCount] = useState(0);\n    const [cameraPermission, setCameraPermission] = useState(null);\n\n    const customiseImage = (image) => {\n        handleImageChange(image, \"file\", (imageSrc) => takePhoto(imageSrc, false));\n        setTimeout(customisePhoto, 100);\n    }\n\n    const startTimer = useCallback(async () => {\n        [\"Smile\", 3, 2, 1, 0].forEach((item, index) => {\n            setTimeout(() => setCounter(item), index * 1000)\n        })\n    }, [])\n\n    const resetAction = useCallback(() => {\n        setMode(\"capture\");\n        setRawImage(null);\n    }, [])\n\n    const uploadImage = useCallback((event) => {\n        const file = event?.target?.files?.[0];\n        setUploadedCount(uploadedCount + 1);\n        handleImageChange(file, \"file\", (imageSrc) => takePhoto(imageSrc, true));\n    }, [uploadedCount])\n\n    const selectMediaMode = useCallback(async (mediaMode) => {\n        setMode(mediaMode);\n        if(mediaMode === \"capture\") await startTimer();\n        if(mediaMode === \"upload\" && uploaderRef?.current) await uploaderRef?.current?.click();\n    }, [])\n\n    // useEffect(async () => {\n    //     if(counter == 0) {\n    //         if(webcamRef?.current) {\n    //             setCounter(null);\n    //             const imageSrc = await webcamRef?.current?.getScreenshot();\n    //             handleImageChange(imageSrc, \"blob\", (imageSrc) => takePhoto(imageSrc, true));\n    //         }\n    //     }\n    // }, [counter])\n\n\n    useEffect(() => {\n        if (counter === 0) {\n            if (webcamRef?.current?.video) {\n                setCounter(null);\n\n                const video = webcamRef.current.video;\n                if (!video) return;\n\n                // Create offscreen canvas at camera's native resolution\n                const canvas = document.createElement(\"canvas\");\n                canvas.width = video.videoWidth;\n                canvas.height = video.videoHeight;\n\n                const ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n\n                // Get PNG blob (full resolution, no quality loss)\n                canvas.toBlob((blob) => {\n                    // Blob ko File me convert karna\n                    const file = new File([blob], \"captured-photo.png\", {\n                        type: \"image/png\",\n                        lastModified: Date.now(),\n                    });\n\n                    // Ab file milegi jisme name, size, type sab hoga\n                    handleImageChangeBlob(file, \"file\", () =>\n                        takePhoto(URL.createObjectURL(file), true)\n                    );\n                }, \"image/png\");\n            }\n        }\n    }, [counter]);\n\n\n    const requestCameraAccess = async () => {\n        try {\n            // Stop old stream if exists\n            const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n\n            if (webcamRef.current) {\n                webcamRef.current.srcObject = stream;\n            }\n\n            setCameraPermission(\"granted\");\n\n        } catch (err) {\n            console.warn(\"Camera error:\", err.name, err.message);\n\n            // Check permission state (Chrome/Firefox only)\n            if (navigator.permissions && navigator.permissions.query) {\n                try {\n                    const status = await navigator.permissions.query({ name: \"camera\" });\n                    setCameraPermission(status.state); // \"granted\" | \"prompt\" | \"denied\"\n                    return;\n                } catch {\n                    console.log(\"Permissions API not supported (Safari likely)\");\n                }\n            }\n\n            // Safari fallback\n            setCameraPermission(\"prompt\");\n        }\n    };\n\n\n    useEffect(() => {\n        if (!/Safari/i.test(navigator.userAgent) || /Chrome/i.test(navigator.userAgent)) {\n        // Non-Safari: try automatically on load\n        requestCameraAccess();\n        }\n    }, []);\n\n    useEffect(() => {\n        const checkCameraPermission = async () => {\n            try {\n                const result = await navigator.permissions.query({ name: 'camera' });\n                if (result.state !== cameraPermission) {\n                    setCameraPermission(result.state);\n                }\n            } catch (err) {\n                console.warn('Permissions API not fully supported', err);\n            }\n        };\n         setInterval(checkCameraPermission, 2000);\n\n         return () => {\n            clearInterval(checkCameraPermission);\n         }\n    }, [cameraPermission]);\n\n    return (\n        <>\n            <div className=\"pb_user_photo_box\">\n               {rawImage ?  <ImageEditor photoBtnRef={photoBtnRef} imageUrl={rawImage?.src ?? \"\"} customiseImage={customiseImage} />  :\n                <> <ImagePreview  cameraPermission={cameraPermission} {...{ mode, rawImage, canvasRef, canvasCursor, webcamRef, counter }} />  \n                  {!rawImage ? <div id=\"camera-disabled-message\" className=\"pb-camera-disabled\" style={{ display: cameraPermission === \"granted\" || rawImage && !isMobile ? \"none\" : \"flex\" }}>\n                        <img src={`${PhotoBoothMediaUrl}images/photobooth/camera-disabled.svg`} alt=\"camera-disabled\" />\n                        <p className=\"pb_camera_disabled_text\">Please reload and allow camera<br/>access when prompted.</p>\n                        {/* {isCameraSettingsAvailable ? <button id=\"open-settings-button\" onClick={() => window.open(isCameraSettingsAvailable, \"_blank\")}>\n                         <img src={`${CloudUrl}/media/images/photobooth/refresh.svg`} alt=\"refresh\" width=\"20\" height=\"20\" /> Reload Now\n                        </button> : null} */}\n                        <p className=\"pb_camera_disabled_text_bottom\">In case this doesn't work, please<br/>check the camera permissions in <br/>your browser settings.</p>\n                    </div> : null}</> }\n                {rawImage ? <div className=\"pb_take_photo\">\n                    <Button className=\"pb_buttons_transparent\" icon=\"retake\" children=\"Try Again\" onClick={resetAction} />\n                    <Button className=\"pb_buttons heighlight\" children=\"Looks Good!\" onClick={() => photoBtnRef?.current?.click()} />\n                </div> : <div className=\"pb_user_buttons\">\n                    {cameraPermission === \"granted\" ? <Button className=\"pb_buttons heighlight\" icon=\"camera\" children=\"Strike a Pose\" onClick={() => selectMediaMode(\"capture\")} /> : null}\n                    <Button className=\"pb_buttons\" icon=\"upload\" children=\"Upload from Gallery\" onClick={() => selectMediaMode(\"upload\")} />\n                </div>}\n            </div>\n            <input ref={uploaderRef} key={uploadedCount} type=\"file\" accept=\"image/*\" style={{ display: \"none\" }} onChange={uploadImage} />\n        </>\n    )\n}\n\nexport default UserPhoto","import { useEffect, useMemo, useRef, useState } from 'react';\nimport * as selfieSegmentationModule from \"@mediapipe/selfie_segmentation\";\nimport Cards from './Cards/Cards'\nimport Customization from './Customization'\nimport TopBar from './TopBar/TopBar'\nimport UserPhoto from './UserPhoto/UserPhoto';\nimport { detectMobile } from '../../../utils';\nimport { CANVAS_HEIGHT, CANVAS_WIDTH, PHOTOBOT_VERSION } from './utils/constant';\nimport { getInitialRatio, isOverResizeHandle, isOverRotationHandle, isOverSticker, isOverText, isOverTextResizeHandle, isOverTextRotationHandle, rotatePoint } from './utils';\nimport ReviewHub from '../UserComponents/ReviewHub';\nimport './photobooth.scss';\n\n\n// Constants for sticker interaction\nconst TEXT_PLACEHOLDER = \"Your Text Here\";\n\nconst PhotoBooth = (props) => {\n    // Refs for canvas elements, and the HTML text overlay\n    const canvasRef = useRef(null);\n    const deleteButtonRefs = useRef({});\n    const textDeleteButtonRefs = useRef({});\n\n    const [loading, setLoading] = useState(false);\n    // State variables for application logic\n    const [rawImage, setRawImage] = useState(null); // image before cropping\n    const [capturedImage, setCapturedImage] = useState(null); // image after cropping\n    const [isCustomization, setIsCustomization] = useState(false);\n    const [isBackHandle, setisBackHandle] = useState(0);\n    const [segmentationMask, setSegmentationMask] = useState(null);\n    const [frameOverlay, setFrameOverlay] = useState(null);\n    const [bgImg, setBgImg] = useState(null); // Stores the loaded background image\n    const [stickers, setStickers] = useState([]); // Array of all stickers on the canvas\n    const [canvasElements, setCanvasElements] = useState([]); // Array of all elements (stickers, text) on the canvas\n    const [selectedBg, setSelectedBg] = useState(null);\n    const [selectedFrame, setSelectedFrame] = useState(null);\n    const [uploadImg, setUploadImg] = useState(null);\n    const [uploadType, setUploadType] = useState(props?.snapType);\n    const [activeText, setActiveText] = useState(null);\n\n    // States for element interaction (generalized for stickers and text)\n    const [activeTextIndex, setActiveTextIndex] = useState(null);\n    const [activeStickerIndex, setActiveStickerIndex] = useState(null); // Index of the sticker being interacted with\n    const [dragMode, setDragMode] = useState(null); // 'move', 'resize', 'rotate', or null\n    const [dragStart, setDragStart] = useState(null);\n    const [canvasCursor, setCanvasCursor] = useState('default');\n\n    // States for saving and download\n    const [canvasDims, setCanvasDims] = useState({ width: CANVAS_WIDTH, height: CANVAS_HEIGHT });\n\n    const isMobile = useMemo(detectMobile, [])\n\n    const toggleImageAlteration = (value) => {\n        setLoading(value);\n    }\n\n    // Function to generate selfie segmentation mask using MediaPipe\n    const generateSegmentation = async (image) => {\n        const selfieSegmentation = new selfieSegmentationModule.SelfieSegmentation({\n            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${file}`\n        });\n\n        selfieSegmentation.setOptions({ modelSelection: 1 });\n\n        selfieSegmentation.onResults((results) => {\n            setSegmentationMask(results.segmentationMask);\n        });\n\n        const tempCanvas = document.createElement(\"canvas\");\n        tempCanvas.width = image.width;\n        tempCanvas.height = image.height;\n        const tempCtx = tempCanvas.getContext(\"2d\");\n        tempCtx.drawImage(image, 0, 0, image.width, image.height);\n\n        try {\n            await selfieSegmentation.send({ image: tempCanvas });\n        } catch (error) {\n            console.error(\"Error sending image to MediaPipe:\", error);\n        }\n    }\n\n    const customisePhoto = () => {\n        setRawImage(null);\n        setFrameOverlay(null);\n        setBgImg(null); // Stores the loaded background image\n        setStickers([]); // Array of all stickers on the canvas\n        setCanvasElements([]); // Array of all elements (stickers, text) on the canvas\n        setSelectedBg(null);\n        setSelectedFrame(null);\n        setActiveTextIndex(null);\n        setActiveStickerIndex(null); // Index of the sticker being interacted with\n        setIsCustomization(true);\n    }\n\n    // Function to capture a photo from the webcam\n    const takePhoto = async (imageSrc, isRawImage) => {\n        if (!imageSrc) {\n            console.error(\"Failed to capture screenshot from webcam.\");\n            return;\n        }\n\n        const img = new Image();\n        img.crossOrigin = \"anonymous\"; \n        img.src = imageSrc;\n        img.onload = async () => {\n            if(isRawImage) setRawImage(img);\n            else setCapturedImage(img);\n            setCanvasDims({ width: img.width, height: img.height }); // Ensure canvas dims are set on photo capture\n            await generateSegmentation(img);\n        };\n        img.onerror = () => {\n            console.error(\"Failed to load captured image.\");\n        };\n    }\n\n    const backAction = () => {\n        if (isCustomization) {\n            setRawImage(capturedImage);\n            if (uploadImg && !isBackHandle) {\n                setIsCustomization(true);\n                setisBackHandle(1);\n                setUploadType(3);\n                setRawImage(0);\n\n            } else {\n                setIsCustomization(false);\n                setisBackHandle(0);\n            }\n        } else {\n            setIsCustomization(false);\n            setRawImage(null);\n            setUploadType(!rawImage ? props?.snapType : uploadImg && uploadType === 2 ? 3 : uploadType);\n        }\n    };\n\n    // Helper function to get mouse coordinates relative to the canvas's drawing dimensions\n    const getCanvasCoordsFromEvent = (e) => {\n        const canvas = canvasRef.current;\n        const rect = canvas.getBoundingClientRect();\n        // Calculate coordinates considering the canvas's displayed size vs. its actual drawing size\n        const x = (e.clientX - rect.left) * (canvas.width / rect.width);\n        const y = (e.clientY - rect.top) * (canvas.height / rect.height);\n        return { x, y };\n    };\n\n    const measureTextWidth = (textObj) => {\n        const canvas = canvasRef?.current;\n        if (!canvas || !textObj?.text) return 0;\n    \n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return 0;\n    \n        ctx.save();\n        ctx.font = `${textObj.fontSize || 20}px ${textObj.fontFamily || 'Arial'}`;\n    \n        const lines = textObj.text.split('\\n');\n        const maxLineWidth = Math.max(...lines.map(line => ctx.measureText(line).width));\n    \n        ctx.restore();\n        return maxLineWidth;\n    };\n\n    const onMouseDown = (e) => {\n        const { x: mouseX, y: mouseY } = getCanvasCoordsFromEvent(e, canvasRef);\n        let foundSticker = false;\n        let foundText = false;\n\n        // === CHECK STICKERS ===\n        for (let i = stickers.length - 1; i >= 0; i--) {\n            const sticker = stickers[i];\n\n            const deleteBtn = deleteButtonRefs.current[i];\n            if (deleteBtn) {\n                const { x, y, size } = deleteBtn;\n                const dx = mouseX - x;\n                const dy = mouseY - y;\n                const dist = Math.sqrt(dx * dx + dy * dy);\n            \n                const radius = size / 2; // match actual drawn size (22 → radius 11, or adjust)\n                const hitbox = Math.max(radius, 30); // min tap area (16px) for usability\n                if (dist <= hitbox*4) {\n                    setStickers((prev) => prev.filter((_, idx) => idx !== i));\n                    setActiveStickerIndex(null);\n                    return;\n                }\n            }\n\n            if (isOverRotationHandle(sticker, mouseX, mouseY)) {\n                setActiveStickerIndex(i);\n                setDragMode(\"rotate\");\n                setDragStart({\n                    x: mouseX,\n                    y: mouseY,\n                    centerX: sticker.x + (sticker.img.width * sticker.scale) / 2,\n                    centerY: sticker.y + (sticker.img.height * sticker.scale) / 2,\n                    initialAngle: sticker.rotation || 0,\n                });\n                foundSticker = true;\n                break;\n            }\n\n            if (isOverResizeHandle(sticker, mouseX, mouseY)) {\n                setActiveStickerIndex(i);\n                setDragMode(\"resize\");\n                setDragStart({\n                    x: mouseX,\n                    y: mouseY,\n                    initialScale: sticker.scale,\n                    initialWidth: sticker.img.width,\n                });\n                foundSticker = true;\n                break;\n            }\n\n            if (isOverSticker(sticker, mouseX, mouseY)) {\n                setActiveStickerIndex(i);\n                setDragMode(\"move\");\n                setDragStart({\n                    x: mouseX,\n                    y: mouseY,\n                    initialX: sticker.x,\n                    initialY: sticker.y,\n                });\n                foundSticker = true;\n                break;\n            }\n        }\n\n        // === IF NO STICKER WAS SELECTED, CHECK TEXT ELEMENTS ===\n        if (!foundSticker) {\n            const { initialHeightRatio, initialWidthRatio } = getInitialRatio(capturedImage);\n            for (let i = canvasElements.length - 1; i >= 0; i--) {\n                const text = canvasElements[i];\n                const width = measureTextWidth(text);\n                const deleteBtn = textDeleteButtonRefs.current?.[i]\n                if (deleteBtn) {\n                    const { x, y, size } = deleteBtn;\n                \n                    const scaleFactor = canvasElements[i].scale || 1;\n                    const dx = mouseX - x;\n                    const dy = mouseY - y;\n                    const dist = Math.sqrt(dx * dx + dy * dy);\n                    let fraction = 1;\n                    if(scaleFactor < 0.5) fraction =  3.5;\n                    else if(scaleFactor < 0.6) fraction =  3;\n                    else if(scaleFactor < 0.7) fraction =  2.4;\n                    else if(scaleFactor < 0.8) fraction =  1.9;\n                    else if(scaleFactor < 0.93) fraction =  1.6;\n                    const dynamicSize = Math.max(size, width * 0.02 * scaleFactor * ((initialWidthRatio + initialHeightRatio) * 2));// upper bound optional\n                    if ((dist / fraction) < dynamicSize) {\n                        setCanvasElements((prev) => prev.filter((_, idx) => idx !== i));\n                        setActiveTextIndex(null);\n                        setActiveText(null);\n                        return;\n                    }\n                }\n\n                if (isOverTextRotationHandle(text, mouseX, mouseY, width, capturedImage)) {\n                    setActiveTextIndex(i);\n                    setActiveText(null);\n                    setDragMode(\"rotate-text\");\n                    setDragStart({\n                        x: mouseX,\n                        y: mouseY,\n                        centerX: text.x,\n                        centerY: text.y,\n                        initialAngle: text.rotation || 0,\n                    });\n                    foundText = true;\n                    break;\n                }\n\n                if (isOverTextResizeHandle(text, mouseX, mouseY, width, capturedImage)) {\n                    setActiveText(null);\n                    setActiveTextIndex(i);\n                    setActiveStickerIndex(null);\n                    setDragMode('resize-text');\n                    setDragStart({\n                        x: mouseX,\n                        y: mouseY,\n                        initialScale: text.scale,\n                        initialWidth: width,\n                    });\n                    foundText = true;\n                    break;\n                }\n\n                if (isOverText(text, mouseX, mouseY, width, capturedImage)) {\n                    setActiveText({ index: i, count: (activeTextIndex == i ? activeText?.count >= 2 ? 2 : (activeText?.count ?? 0) + 1 : 1) });\n                    setActiveTextIndex(i);\n                    setDragMode(\"move-text\");\n                    setDragStart({\n                        x: mouseX,\n                        y: mouseY,\n                        initialX: text.x,\n                        initialY: text.y,\n                    });\n                    foundText = true;\n                    break;\n                }\n            }\n        }\n\n        // Clear selection if clicked outside everything\n        if (!foundSticker && !foundText) {\n            setActiveStickerIndex(null);\n            setActiveTextIndex(null);\n            setDragMode(null);\n            setDragStart(null);\n            setActiveText(null);\n        }\n    };    \n\n    const onMouseMove = (e) => {\n        const { x: mouseX, y: mouseY } = getCanvasCoordsFromEvent(e);\n    \n        let newCursor = 'default';\n        let foundHover = false;\n    \n        // 🔍 Check for hover over text (top-most first)\n        for (let i = canvasElements.length - 1; i >= 0; i--) {\n            const text = canvasElements[i];\n            const width = measureTextWidth(text);\n            if (isOverTextRotationHandle(text, mouseX, mouseY, width, capturedImage)) {\n                newCursor = 'crosshair';\n                foundHover = true;\n                break;\n            } else if (isOverTextResizeHandle(text, mouseX, mouseY, width, capturedImage)) {\n                newCursor = 'nwse-resize';\n                foundHover = true;\n                break;\n            } else if (isOverText(text, mouseX, mouseY, width, capturedImage)) {\n                newCursor = 'grab';\n                foundHover = true;\n                break;\n            }\n        }\n    \n        // 🔍 If not hovering text, check stickers\n        if (!foundHover) {\n            for (let i = stickers.length - 1; i >= 0; i--) {\n                const sticker = stickers[i];\n                if (isOverRotationHandle(sticker, mouseX, mouseY)) {\n                    newCursor = 'crosshair';\n                    foundHover = true;\n                    break;\n                } else if (isOverResizeHandle(sticker, mouseX, mouseY)) {\n                    newCursor = 'nwse-resize';\n                    foundHover = true;\n                    break;\n                } else if (isOverSticker(sticker, mouseX, mouseY)) {\n                    newCursor = 'grab';\n                    foundHover = true;\n                    break;\n                }\n            }\n        }\n    \n        // Show grabbing cursor if dragging\n        if (dragMode === 'move' && (activeStickerIndex !== null || activeTextIndex !== null)) {\n            newCursor = 'grabbing';\n        }\n    \n        setCanvasCursor(newCursor);\n    \n        // 💥 Abort if not dragging\n        if (!dragMode || !dragStart) return;\n    \n        const dx = mouseX - dragStart.x;\n        const dy = mouseY - dragStart.y;\n    \n        // ✏️ Dragging sticker\n        if (activeStickerIndex !== null) {\n            setStickers((prev) => {\n                const updated = [...prev];\n                const item = { ...updated[activeStickerIndex] };\n    \n                if (dragMode === 'move') {\n                    item.x = dragStart.initialX + dx;\n                    item.y = dragStart.initialY + dy;\n                } else if (dragMode === 'resize') {\n                    const newWidth = dragStart.initialWidth * dragStart.initialScale + dx;\n                    const newScale = Math.max(0.05, newWidth / item.img.width);\n                    item.scale = newScale;\n                } else if (dragMode === 'rotate') {\n                    const angleStart = Math.atan2(dragStart.y - dragStart.centerY, dragStart.x - dragStart.centerX);\n                    const angleCurrent = Math.atan2(mouseY - dragStart.centerY, mouseX - dragStart.centerX);\n                    const angleDelta = angleCurrent - angleStart;\n                    const degrees = (angleDelta * 180) / Math.PI;\n                    item.rotation = (dragStart.initialAngle + degrees) % 360;\n                }\n    \n                updated[activeStickerIndex] = item;\n                return updated;\n            });\n        }\n    \n        // ✏️ Dragging text\n        if (activeTextIndex !== null) {\n            setCanvasElements((prev) => {\n                const updated = [...prev];\n                const item = { ...updated[activeTextIndex] };\n                if (dragMode === 'move-text') {\n                    item.x = dragStart.initialX + dx;\n                    item.y = dragStart.initialY + dy;\n                } else if (dragMode === 'resize-text') {\n                    const newWidth = dragStart.initialWidth * dragStart.initialScale + dx;\n                    const newScale = Math.max(0.1, newWidth / measureTextWidth(item));\n                    item.scale = newScale;\n                } else if (dragMode === 'rotate-text') {\n                    const angleStart = Math.atan2(dragStart.y - dragStart.centerY, dragStart.x - dragStart.centerX);\n                    const angleCurrent = Math.atan2(mouseY - dragStart.centerY, mouseX - dragStart.centerX);\n                    const angleDelta = angleCurrent - angleStart;\n                    const degrees = (angleDelta * 180) / Math.PI;\n                    item.rotation = (dragStart.initialAngle + degrees) % 360;\n                }\n    \n                updated[activeTextIndex] = item;\n                return updated;\n            });\n        }\n    };\n\n    // Event handler for mouse up on the canvas (ends drag/resize)\n    const onMouseUp = () => {\n        setDragMode(null);\n        setDragStart(null);\n        setCanvasCursor('default'); // Reset cursor\n    }\n\n    // Function to add a new sticker to the canvas\n    const addSticker = (src) => {\n        const img = new Image();\n        img.crossOrigin = \"anonymous\";\n        toggleImageAlteration(true);\n        img.src = `https://cdn.taggbox.com/v7/${src}?v=${PHOTOBOT_VERSION}`;\n        img.onload = () => {\n            toggleImageAlteration(false);\n            // Use canvasDims for initial positioning and scaling\n            const width = canvasDims.width;\n            const height = canvasDims.height;\n\n            // Target sticker width depending on canvas size\n            const targetWidth = width / (isMobile ? 4 : 3);\n\n            // Keep aspect ratio for height\n            const targetHeight = (img.height / img.width) * targetWidth;\n            const scaleRequired = targetWidth / img.width;\n            img[\"height\"] = ((img.height * scaleRequired));\n            img[\"width\"] = ((img.width * scaleRequired));\n\n            // ✅ Store resized dimensions directly on the sticker\n            setActiveTextIndex(null);\n            setStickers((prev) => {\n                const newStickers = [\n                    ...prev,\n                    {\n                        img,\n                        x: width / 2 - targetWidth / 2,   // Center horizontally\n                        y: height / 2 - targetHeight / 2, // Center vertically\n                        scale: 1,\n                        url: src,\n                        rotation: 0, // Start with no rotation\n                    },\n                ];\n                setActiveStickerIndex(newStickers.length - 1);\n                return newStickers;\n            });\n        };\n        img.onerror = () => {\n            toggleImageAlteration(false);\n            console.error(`Failed to load sticker image: ${src}`);\n        };\n    };\n\n    // Function to add a new text element to the canvas\n    const addTextElement = () => {\n        const width = canvasDims.width;\n        const height = canvasDims.height;\n\n        const fontSize = 28;\n        const initialScale = 1;\n\n        const newElement = {\n            text: TEXT_PLACEHOLDER,\n            x: width / 2, // center horizontally\n            y: height / 2, // center vertically\n            scale: initialScale,\n            rotation: 0,\n            fontSize,\n            fontFamily: \"Georgia\",\n            color: \"#000000\",\n            backgroundColor: \"white\",\n            align: \"center\",\n        };\n\n        setActiveStickerIndex(null);\n        setCanvasElements((prev) => {\n            const newTextElements = [...prev, newElement];\n            setActiveTextIndex(newTextElements.length - 1); // make new text active\n            return newTextElements;\n        });\n    };\n\n    // useEffect hook to draw on the canvas whenever relevant states change\n    useEffect(() => {\n        // Only draw if an image and segmentation mask are available\n        if (!capturedImage || !segmentationMask) return;\n\n        const canvas = canvasRef.current;\n        if (!canvas) return; // Ensure canvas element exists\n        const ctx = canvas.getContext(\"2d\");\n\n        // Use canvasDims from state for consistent dimensions\n        const width = canvasDims.width;\n        const height = canvasDims.height;\n\n        // Set canvas dimensions\n        canvas.width = width;\n        canvas.height = height;\n\n        const { initialWidthRatio, initialHeightRatio } = getInitialRatio(capturedImage);\n\n        // Create an offscreen buffer canvas for drawing to prevent flickering\n        const bufferCanvas = document.createElement(\"canvas\");\n        bufferCanvas.width = width;\n        bufferCanvas.height = height;\n        const bufferCtx = bufferCanvas.getContext(\"2d\");\n\n        // Clear the buffer canvas\n        bufferCtx.clearRect(0, 0, width, height);\n\n        // --- Logic for Background Replacement ---\n        if (selectedBg && bgImg) {\n            // If a background is selected, perform segmentation and composite\n            const foregroundCanvas = document.createElement('canvas');\n            foregroundCanvas.width = width;\n            foregroundCanvas.height = height;\n            const fgCtx = foregroundCanvas.getContext('2d');\n\n            fgCtx.drawImage(capturedImage, 0, 0, width, height);\n            fgCtx.globalCompositeOperation = 'destination-in';\n            fgCtx.drawImage(segmentationMask, 0, 0, width, height);\n            fgCtx.globalCompositeOperation = 'source-over';\n\n            bufferCtx.drawImage(bgImg, 0, 0, width, height);\n            bufferCtx.drawImage(foregroundCanvas, 0, 0, width, height);\n        } else {\n            // If NO background is selected, draw the ORIGINAL captured image\n            bufferCtx.drawImage(capturedImage, 0, 0, width, height);\n        }\n\n        // Ensure globalCompositeOperation is 'source-over' for subsequent elements\n        bufferCtx.globalCompositeOperation = \"source-over\";\n\n        // Apply frame overlay if available - it's static and fills the canvas\n        if (frameOverlay) {\n            bufferCtx.drawImage(frameOverlay, 0, 0, width, height);\n        }\n\n        // Draw all active stickers with their positions, scales, and rotations\n        stickers.forEach((sticker, index) => {\n            const stickerWidth = sticker.img.width * sticker.scale;\n            const stickerHeight = sticker.img.height * sticker.scale;\n            const centerX = sticker.x + stickerWidth / 2;\n            const centerY = sticker.y + stickerHeight / 2;\n            // ✅ Dynamic handle/icon sizes relative to canvas size\n            const handleRadius = Math.max(canvas.width, canvas.height) * 0.04; // ~4% of canvas\n            const fontSize = Math.max(canvas.width, canvas.height) * 0.05;     // ~5% of canvas\n            const otherFontSize = fontSize + 20;\n            const border = (fontSize)\n\n            bufferCtx.save(); // Save the current canvas state\n\n            // Translate to the sticker's center, rotate, then translate back\n            bufferCtx.translate(centerX, centerY);\n            bufferCtx.rotate((sticker.rotation || 0) * Math.PI / 180); // Convert degrees to radians\n            bufferCtx.drawImage(sticker.img, -stickerWidth / 2, -stickerHeight / 2, stickerWidth, stickerHeight);\n\n            // Draw border and handles if this is the active sticker\n            if (index === activeStickerIndex) {\n                bufferCtx.strokeStyle = \"#2b2b2b\"; // Blue border\n                bufferCtx.lineWidth = 2;\n                bufferCtx.setLineDash([5, 3]); // [dashLength, gapLength]\n                bufferCtx.strokeRect(-stickerWidth / 2, -stickerHeight / 2, stickerWidth, stickerHeight);\n                bufferCtx.setLineDash([]); // Reset to solid line if needed after this\n\n                const resizeIcon = \"⤡\";\n\n                const resizeHandleX = (stickerWidth / 2);\n                const resizeHandleY = (stickerHeight / 2);\n\n                // Draw background circle\n                bufferCtx.fillStyle = \"#000\"; // Outer circle background color\n                bufferCtx.beginPath();\n                bufferCtx.arc(resizeHandleX - 2, resizeHandleY - 4, handleRadius, 0, 2 * Math.PI);\n                bufferCtx.fill();\n\n                // Draw resize icon centered\n                bufferCtx.fillStyle = \"white\";\n                bufferCtx.font = `bold ${otherFontSize}px Arial`;\n                bufferCtx.textAlign = \"center\";\n                bufferCtx.textBaseline = \"middle\";\n                bufferCtx.fillText(resizeIcon, resizeHandleX, resizeHandleY - 5);\n\n\n                // Draw Rotation Handle (top-center, above sticker)\n                const rotationHandleX = stickerWidth / 2;  // Right edge from center\n                const rotationHandleY = -stickerHeight / 2;\n\n                // Draw background circle\n                bufferCtx.beginPath();\n                bufferCtx.fillStyle = \"#000\"; // Background color\n                bufferCtx.arc(rotationHandleX, rotationHandleY, handleRadius, 0, 2 * Math.PI);\n                bufferCtx.fill();\n\n                // Draw icon/text\n                bufferCtx.fillStyle = \"#fff\";\n                bufferCtx.font = `bold ${otherFontSize}px Arial`;\n                bufferCtx.textAlign = \"center\";\n                bufferCtx.textBaseline = \"middle\";\n                bufferCtx.fillText('⟳', rotationHandleX + 1, rotationHandleY - 1);\n\n\n                // ✅ Draw Delete Button (top-right corner)\n                const deleteBtnSize = 24;\n                const deleteBtnX = -(stickerWidth / 2) - (deleteBtnSize / 2) + 5;  // Shift left of center\n                const deleteBtnY = -(stickerHeight / 2) - (deleteBtnSize / 2) + 8; \n                // Top-left corner of sticker (before rotation)\n                const rawDeleteX = centerX + deleteBtnX;\n                const rawDeleteY = centerY + deleteBtnY;\n\n                // Rotate that point smoothly around the sticker's center\n                const deleteBtnPos = rotatePoint(\n                    rawDeleteX,\n                    rawDeleteY,\n                    centerX,\n                    centerY,\n                    sticker.rotation || 0\n                );\n                deleteButtonRefs.current[index] = {\n                    x: deleteBtnPos.x,\n                    y: deleteBtnPos.y,\n                    size: deleteBtnSize,\n                };\n                // Drawing the button\n                bufferCtx.beginPath();\n                bufferCtx.arc(deleteBtnX + 4, deleteBtnY + 4, handleRadius, 0, 2 * Math.PI);\n                bufferCtx.fillStyle = \"black\";\n                bufferCtx.fill();\n                bufferCtx.fillStyle = \"#fff\";\n                bufferCtx.font = `bold ${fontSize}px Arial`;\n                bufferCtx.textAlign = \"center\";      // horizontal center\n                bufferCtx.textBaseline = \"middle\";   // vertical center\n                bufferCtx.fillText(\"✕\", deleteBtnX + 5, deleteBtnY + 5);\n            }\n            bufferCtx.restore(); // Restore the canvas state\n        });\n\n        const scaleRatio = Math.max(initialWidthRatio, initialHeightRatio);\n        \n\n        // Draw all active text sections with their positions, scales, and rotations\n        canvasElements.forEach((element, index) => {\n            bufferCtx.save();\n            bufferCtx.translate(element.x, element.y);\n            bufferCtx.rotate((element.rotation * Math.PI) / 180);\n            bufferCtx.scale(element.scale, element.scale);\n\n            // Set font and alignment styles\n            bufferCtx.font = `${(element.fontSize * scaleRatio)}px ${element.fontFamily || 'Arial'}`;\n            bufferCtx.textAlign = element.align || 'center'; // supports 'left', 'center', 'right'\n            bufferCtx.textBaseline = \"middle\";\n\n            // Split lines\n            const lines = element.text?.split('\\n') || [];\n            const lineCount = lines.length;\n\n            // Normalize font size\n            const normalizedFontSize = element.fontSize * scaleRatio;\n\n            // Set font & alignment\n            bufferCtx.font = `${normalizedFontSize}px ${element.fontFamily || 'Arial'}`;\n            bufferCtx.textAlign = element.align || 'center';\n            bufferCtx.textBaseline = \"middle\";\n\n            // Measure the widest line\n            const maxLineWidth = Math.max(...lines.map(line => bufferCtx.measureText(line).width));\n\n            // Line height & padding (normalized)\n            const lineHeight = normalizedFontSize * 1.2;\n            const padding = 15 * scaleRatio;\n\n            // Outline/background dimensions\n            const outlineWidth = maxLineWidth + padding * 2;\n            const outlineHeight = lineHeight * lineCount + padding * 2;\n\n            const bgWidth = outlineWidth;\n            const bgHeight = outlineHeight;\n\n            const xOffset = -bgWidth / 2;\n\n            if (element.backgroundColor) {\n                bufferCtx.fillStyle = element.backgroundColor;\n                bufferCtx.fillRect(xOffset, -bgHeight / 2, bgWidth, bgHeight);\n            }\n\n            // Text fill\n            if (index !== activeTextIndex) {\n                // Background color box\n                bufferCtx.fillStyle = element.color || \"#000000\";\n                lines.forEach((line, i) => {\n                    let offsetX = 0;\n                    if(bufferCtx.textAlign == \"center\") offsetX = 0;\n                    else if(bufferCtx.textAlign == \"left\") offsetX = -bgWidth / 2 + 10;\n                    else if(bufferCtx.textAlign == \"right\") offsetX = bgWidth / 2  - 10;\n                    bufferCtx.fillText(line, offsetX, i * lineHeight - ((lines.length - 1) * lineHeight) / 2);\n                });\n            }\n\n            // If selected, draw bounding box + handles\n            if (index === activeTextIndex) {\n                // const textareaElement = document.getElementById(`text-${activeTextIndex}`);\n                // if (textareaElement) {\n                //     textareaElement.focus();\n                //     if (textareaElement && element.text == TEXT_PLACEHOLDER) {\n                //         textareaElement.select(); // selects all text\n                //     }\n                // }\n\n                bufferCtx.strokeStyle = \"#2b2b2b\";\n                bufferCtx.lineWidth = 2 * scaleRatio;\n                bufferCtx.setLineDash([5, 3]); // [dashLength, gapLength]\n                bufferCtx.strokeRect(xOffset, -bgHeight / 2, bgWidth, bgHeight);\n                bufferCtx.setLineDash([]); // Reset to solid line if needed after this\n\n                // ✅ Draw Delete Button (top-left corner of text)\n                const deleteBtnSize = 22;\n                const angleRad = (element.rotation || 0) * Math.PI / 180;\n\n                // These are relative to the text center\n                const deleteOffsetX = -outlineWidth / 2 - deleteBtnSize / 2;\n                const deleteOffsetY = -outlineHeight / 2 - deleteBtnSize / 2;\n\n                // Convert to canvas absolute coords using rotation\n                const deleteX = element.x + deleteOffsetX * Math.cos(angleRad) - deleteOffsetY * Math.sin(angleRad);\n                const deleteY = element.y + deleteOffsetX * Math.sin(angleRad) + deleteOffsetY * Math.cos(angleRad);\n\n                // Store reference for hit detection\n                textDeleteButtonRefs.current[index] = {\n                    x: deleteX,\n                    y: deleteY,\n                    size: Math.max(isMobile ? 15 : 10, deleteBtnSize * element.scale),\n                };\n\n                // DELETE handle (top-left)\n                bufferCtx.fillStyle = \"black\";\n                bufferCtx.beginPath();\n                bufferCtx.arc(xOffset, - bgHeight / 2, scaleRatio * 14, 0, 2 * Math.PI);\n                bufferCtx.fill();\n                bufferCtx.fillStyle = \"#fff\";\n                bufferCtx.font = `bold ${scaleRatio * 16}px Arial`;\n                bufferCtx.textAlign = \"center\";      // horizontal center\n                bufferCtx.textBaseline = \"middle\";   // vertical center\n                bufferCtx.fillText(\"✕\", xOffset, (-bgHeight / 2) + 2);\n\n                // ROTATE handle (top-right)\n                bufferCtx.fillStyle = \"black\";\n                bufferCtx.beginPath();\n                bufferCtx.arc(xOffset + bgWidth, -bgHeight / 2, scaleRatio * 14, 0, 2 * Math.PI);\n                bufferCtx.fill();\n                bufferCtx.fillStyle = \"white\";\n                bufferCtx.font = `bold ${scaleRatio * 24}px Arial`;\n                bufferCtx.textAlign = \"center\";      // horizontal center\n                bufferCtx.textBaseline = \"middle\";   // vertical center\n                bufferCtx.fillText('⟳', (xOffset + bgWidth) + 1, (-bgHeight / 2) - 1);\n\n                // RESIZE handle (bottom-right)\n                bufferCtx.fillStyle = \"black\";\n                bufferCtx.beginPath();\n                bufferCtx.arc(xOffset + bgWidth, bgHeight / 2, scaleRatio * 14, 0, 2 * Math.PI);\n                bufferCtx.fill();\n                bufferCtx.fillStyle = \"white\";\n                bufferCtx.font = `bold ${scaleRatio * 24}px Arial`;\n                bufferCtx.textAlign = \"center\";      // horizontal center\n                bufferCtx.textBaseline = \"middle\";   // vertical center\n                bufferCtx.fillText(\"⤡\", xOffset + bgWidth, bgHeight / 2);\n            }\n            bufferCtx.restore();\n        });\n\n        // Draw the buffered content to the main visible canvas\n        ctx.clearRect(0, 0, width, height);\n        ctx.drawImage(bufferCanvas, 0, 0);\n\n        // The saving logic has been moved to handleSave, so removed from here.\n    }, [capturedImage, segmentationMask, frameOverlay, stickers, activeStickerIndex, canvasElements, activeTextIndex, bgImg, isCustomization, canvasDims, uploadType]);\n\n    // useEffect hook to load the selected background image\n    useEffect(() => {\n        if (!selectedBg) {\n            setBgImg(null); // Clear background if none selected\n            return;\n        }\n        const img = new Image();\n        img.crossOrigin = \"anonymous\";\n        img.src = `https://cdn.taggbox.com/v7/${selectedBg}?v=${PHOTOBOT_VERSION}`;\n        toggleImageAlteration(true);\n        img.onload = () => {\n            setBgImg(img);\n            toggleImageAlteration(false);\n        };\n        img.onerror = () => {\n            console.error(`Failed to load background image: ${selectedBg}`);\n            toggleImageAlteration(false);\n        }\n    }, [selectedBg]);\n\n    // useEffect hook to load the selected frame image (static)\n    useEffect(() => {\n        if (!selectedFrame) {\n            setFrameOverlay(null); // Clear frame if none selected\n            return;\n        }\n        const img = new Image();\n        img.crossOrigin = \"anonymous\";\n        img.src = `https://cdn.taggbox.com/v7/${selectedFrame}?v=${PHOTOBOT_VERSION}`;\n        toggleImageAlteration(true);\n        img.onload = () => {\n            setFrameOverlay(img);\n            toggleImageAlteration(false);\n        };\n        img.onerror = () => {\n            console.error(`Failed to load frame image: ${selectedFrame}`);\n            toggleImageAlteration(false);\n        }\n    }, [selectedFrame]);\n\n    useEffect(() => {\n        let touchStartY = 0;\n        let touchInFreeScrollSection = false;\n\n        const freeScrollSelectors = ['.pb_tabs_content_box', '.pb_photo_booth_h_review']; \n    // Add all your free scroll sections here\n\n    const handleTouchStart = (e) => {\n        touchStartY = e.touches[0].clientY;\n\n        // Check if touch started inside a free-scroll section\n        const target = e.target.closest(freeScrollSelectors.join(','));\n        touchInFreeScrollSection = !!target;\n    };\n\n        const handleTouchMove = (e) => {\n            if (touchInFreeScrollSection) {\n                // Let this section scroll normally\n                return;\n            }\n    \n            // Only block pull-to-refresh if scrolling up from the very top\n            const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n            const yDiff = e.touches[0].clientY - touchStartY;\n\n            if (scrollTop === 0 && yDiff > 0) {\n                e.preventDefault();\n            }\n        };\n        // const element = document.querySelector('.pb_user_photo')\n\n        document.addEventListener(\"touchstart\", handleTouchStart, { passive: false });\n        document.addEventListener(\"touchmove\", handleTouchMove, { passive: false });\n\n        return () => {\n            document.removeEventListener(\"touchstart\", handleTouchStart);\n            document.removeEventListener(\"touchmove\", handleTouchMove);\n        };\n    }, []);\n\n    const uploadFile = (type, image) => { \n        setUploadType(type);\n        setUploadImg(image);\n        setisBackHandle(0);\n    };       \n\n    return (\n        <div className=\"pb_photo_booth_main\">\n            <div className=\"pb_photo_booth_box\">\n                <div className=\"pb_photo_booth_box_inner\">\n                    <TopBar snapType={props.snapType} rawImage={rawImage} capturedImage={capturedImage} uploadImg={uploadImg} uploadType={uploadType} wall={props?.wall} backAction={backAction}/>\n                    <div className={`pb_photo_booth_h ${uploadType === 2 ? 'pb_photo_booth_h_review' : ''}`}>\n                    {uploadType == 1 ? <Cards uploadFile={uploadFile} /> : (\n                            <>\n                                {(uploadType === 2) ? (\n                                <ReviewHub\n                                    isPhotoBooth={uploadImg}\n                                    photoBoothInterface={1}\n                                    wall={props?.wall}\n                                    wallId={props?.wall?.Wall?.id}\n                                    feeds={props?.feeds}\n                                    isFreeAdsStatus={props?.isFreeAdsStatus}\n                                />\n                                ) : !isCustomization ? (\n                                <UserPhoto\n                                    uploadType={uploadType}\n                                    rawImage={rawImage}\n                                    takePhoto={takePhoto}\n                                    canvasRef={canvasRef}\n                                    canvasCursor={canvasCursor}\n                                    setRawImage={setRawImage}\n                                    customisePhoto={customisePhoto}\n                                />\n                                ) : (\n                                <Customization {...{ loading, capturedImage, uploadFile, canvasRef, canvasCursor, selectedBg, setSelectedBg, selectedFrame, setSelectedFrame, addSticker, addTextElement, onMouseDown, onMouseMove, onMouseUp, canvasElements, setCanvasElements, activeTextIndex, photoBoothSettings: props?.wall?.PhotoBoothSettings ?? {}, selectedStickers: stickers, setActiveStickerIndex, setActiveTextIndex, activeText }} />\n                                )}\n                            </>\n                        )}\n                    </div>\n                </div>\n            </div>\n        </div>\n    )\n}\n\nexport default PhotoBooth;"],"names":["Cards","_ref","uploadFile","_jsx","className","children","_jsxs","onClick","src","concat","PhotoBoothMediaUrl","alt","icon","CANVAS_WIDTH","CANVAS_HEIGHT","SETTINGS_TABS","id","label","PHOTOBOT_VERSION","handleImageChangeBlob","mediaContent","type","uploadAction","file","blob","File","fileName","name","lastModified","Date","now","blobToFile","imageUrl","URL","createObjectURL","handleImageChange","console","log","base64ToFile","dataUrl","filename","header","base64","split","mime","match","binary","atob","len","length","u8arr","Uint8Array","i","charCodeAt","error","isOverResizeHandle","sticker","mouseX","mouseY","stickerWidth","img","width","scale","stickerHeight","height","angleRad","rotation","Math","PI","centerX","x","centerY","y","localHandleX","localHandleY","dx","cos","sin","dy","sqrt","getTouchDeviceFraction","isOverSticker","isOverRotationHandle","handleLocalX","handleLocalY","rad","isOverText","textObj","textWidth","capturedImage","_textObj$text","initialWidthRatio","initialHeightRatio","getInitialRatio","fontSize","text","extraHeight","detectMobile","localX","localY","isOverTextResizeHandle","_textObj$text2","scaleRatio","max","lines","handleSize","offsetX","offsetY","isOverTextRotationHandle","textSectionWidth","_textObj$text3","num","fraction","arguments","undefined","image","ImagePreview","rawImage","cameraPermission","mode","counter","canvasRef","canvasCursor","webcamRef","onMouseDown","onMouseMove","onMouseUp","canvasElements","activeTextIndex","setCanvasElements","loading","facingMode","setFacingMode","useState","camKey","setCamKey","random","getLineCount","isMobile","useMemo","handleChange","e","rawText","target","value","wrappedText","inputText","current","element","ctx","document","createElement","getContext","fontFamily","font","words","line","result","splitLongWord","word","temp","char","testLine","measureText","wrapText","prev","map","el","_objectSpread","measureTextWidth","useCallback","useEffect","async","setTimeout","err","startCamera","stopCamera","_webcamRef$current","stream","getTracks","forEach","track","stop","toggleCamera","_Fragment","style","position","display","ref","cursor","onMouseLeave","onTouchStart","isTouch","startsWith","preventDefault","touch","touches","simulatedEvent","clientX","clientY","onTouchMove","onTouchEnd","Webcam","screenshotFormat","videoConstraints","min","ideal","mirrored","onUserMedia","objectFit","borderRadius","index","onChange","wrap","top","left","transform","textAlign","align","transformOrigin","background","backgroundColor","color","overflow","border","outline","padding","maxWidth","wordBreak","whiteSpace","overflowWrap","resize","React","addSticker","stickers","selectedStickers","active","find","item","url","texts","fontFamilies","aligns","bgColors","_canvasElements$activ7","_canvasElements$activ8","addTextElement","colorPicker","setcolorPicker","pickerRef","useRef","handleClickOutside","event","contains","addEventListener","removeEventListener","ChromePicker","updatedColor","hex","change","_canvasElements$activ","_canvasElements$activ2","activeText","indexOf","_canvasElements$activ3","_canvasElements$activ4","activeBgColor","bgColor","_canvasElements$activ5","_canvasElements$activ6","activeFont","addChangesToElement","CloudUrl","imgUrl","imgList","setImgUrl","tabKey","selectedBg","setSelectedBg","selectedFrame","setSelectedFrame","photoBoothSettings","setActiveStickerIndex","setActiveTextIndex","activeTab","setActiveTab","backgrounds","setBackgrounds","frames","setFrames","setStickers","parseStringObj","photo_booth_frames","photo_booth_backgrounds","photo_booth_stickers","tab","TabComponent","Stickers","Text","Button","continueAction","canvas","dataURL","toDataURL","TopBar","props","snapType","uploadType","wall","uploadImg","backAction","goBack","window","location","href","onsiteRedirectUrl","Wall","photoBtnRef","customiseImage","containerRef","imageRef","initialDistanceRef","initialZoomRef","showCropIcon","setShowCropIcon","imageSize","setImageSize","setPosition","zoom","setZoom","containerWidth","containerHeight","handleCapture","originalImage","ratioX","naturalWidth","ratioY","naturalHeight","sx","sy","sWidth","sHeight","drawImage","toBlob","Image","crossOrigin","onload","ratio","scaledWidth","scaledHeight","getDistance","touch1","touch2","handleTouchStart","handleTouchMove","currentDistance","initialDistance","startZoom","scaleFactor","newZoom","container","passive","timer","clearTimeout","margin","touchAction","onWheel","zoomDelta","deltaY","newX","newY","Rnd","size","enableResizing","disableDragging","onDragStop","handleDragStop","d","maxOffsetX","maxOffsetY","zIndex","pointerEvents","userSelect","right","_rawImage$src","takePhoto","setRawImage","customisePhoto","uploaderRef","setCounter","setMode","uploadedCount","setUploadedCount","setCameraPermission","startTimer","resetAction","uploadImage","_event$target","_event$target$files","files","imageSrc","selectMediaMode","_uploaderRef$current","mediaMode","click","video","videoWidth","videoHeight","test","navigator","userAgent","mediaDevices","getUserMedia","srcObject","warn","message","permissions","query","status","state","_unused","requestCameraAccess","checkCameraPermission","setInterval","clearInterval","ImageEditor","_photoBtnRef$current","accept","_props$wall","_props$wall$Wall","_props$wall$PhotoBoot","_props$wall2","deleteButtonRefs","textDeleteButtonRefs","setLoading","setCapturedImage","isCustomization","setIsCustomization","isBackHandle","setisBackHandle","segmentationMask","setSegmentationMask","frameOverlay","setFrameOverlay","bgImg","setBgImg","setUploadImg","setUploadType","setActiveText","activeStickerIndex","dragMode","setDragMode","dragStart","setDragStart","setCanvasCursor","canvasDims","setCanvasDims","toggleImageAlteration","getCanvasCoordsFromEvent","rect","getBoundingClientRect","save","maxLineWidth","restore","bufferCanvas","bufferCtx","clearRect","foregroundCanvas","fgCtx","globalCompositeOperation","handleRadius","otherFontSize","translate","rotate","strokeStyle","lineWidth","setLineDash","strokeRect","resizeIcon","resizeHandleX","resizeHandleY","fillStyle","beginPath","arc","fill","textBaseline","fillText","rotationHandleX","rotationHandleY","deleteBtnSize","deleteBtnX","deleteBtnY","deleteBtnPos","rotatePoint","cx","cy","angle","_element$text","lineCount","normalizedFontSize","lineHeight","outlineWidth","outlineHeight","bgWidth","bgHeight","xOffset","fillRect","deleteOffsetX","deleteOffsetY","deleteX","deleteY","onerror","touchStartY","touchInFreeScrollSection","freeScrollSelectors","closest","join","scrollTop","documentElement","body","yDiff","ReviewHub","isPhotoBooth","photoBoothInterface","wallId","feeds","isFreeAdsStatus","Customization","targetWidth","targetHeight","scaleRequired","newStickers","newElement","newTextElements","foundSticker","foundText","deleteBtn","radius","filter","_","idx","initialAngle","initialScale","initialWidth","initialX","initialY","_textDeleteButtonRefs","_activeText$count","count","newCursor","foundHover","updated","newWidth","newScale","angleStart","atan2","degrees","PhotoBoothSettings","UserPhoto","isRawImage","selfieSegmentation","selfieSegmentationModule","locateFile","setOptions","modelSelection","onResults","results","tempCanvas","send","generateSegmentation"],"sourceRoot":""}